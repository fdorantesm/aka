package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func getAkaDir() string {
	home, err := os.UserHomeDir()
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error obtaining home directory:", err)
		os.Exit(1)
	}
	akaDir := filepath.Join(home, ".aka")
	if _, err := os.Stat(akaDir); os.IsNotExist(err) {
		if err := os.Mkdir(akaDir, 0755); err != nil {
			fmt.Fprintln(os.Stderr, "Error creating", akaDir+":", err)
			os.Exit(1)
		}
	}
	return akaDir
}

func addAlias(akaDir, aliasName, command string) error {
	filePath := filepath.Join(akaDir, aliasName+".alias")
	return os.WriteFile(filePath, []byte(command+"\n"), 0644)
}

func removeAlias(akaDir, aliasName string) error {
	filePath := filepath.Join(akaDir, aliasName+".alias")
	if _, err := os.Stat(filePath); err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("alias '%s' does not exist", aliasName)
		}
		return err
	}
	return os.Remove(filePath)
}

func listAliases(akaDir string, pattern string) error {
	entries, err := os.ReadDir(akaDir)
	if err != nil {
		return err
	}

	// Collect aliases
	type alias struct {
		name string
		cmd  string
	}
	var aliases []alias
	maxNameLen := 5 // minimum "ALIAS"

	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".alias") {
			aliasName := strings.TrimSuffix(entry.Name(), ".alias")
			
			// Filter by pattern if provided
			if pattern != "" {
				matched, err := filepath.Match(pattern, aliasName)
				if err != nil {
					return fmt.Errorf("invalid pattern '%s': %w", pattern, err)
				}
				if !matched {
					continue
				}
			}
			
			content, err := os.ReadFile(filepath.Join(akaDir, entry.Name()))
			if err != nil {
				return err
			}
			cmdStr := strings.TrimSpace(string(content))
			aliases = append(aliases, alias{name: aliasName, cmd: cmdStr})
			if len(aliasName) > maxNameLen {
				maxNameLen = len(aliasName)
			}
		}
	}

	// Handle no results
	if len(aliases) == 0 {
		if pattern != "" {
			fmt.Printf("No aliases found matching '%s'\n", pattern)
		} else {
			fmt.Println("No aliases found")
		}
		return nil
	}

	// Fixed width for command column (fits most terminals)
	maxCmdLen := 70

	// Helper function to wrap text
	wrapText := func(text string, width int) []string {
		var result []string
		// First split by newlines to preserve intentional line breaks
		lines := strings.Split(text, "\n")
		for _, line := range lines {
			if len(line) <= width {
				result = append(result, line)
			} else {
				// Wrap long lines
				for len(line) > width {
					// Try to break at a space
					breakPoint := width
					for i := width; i > width/2; i-- {
						if line[i] == ' ' {
							breakPoint = i
							break
						}
					}
					result = append(result, line[:breakPoint])
					line = line[breakPoint:]
					if len(line) > 0 && line[0] == ' ' {
						line = line[1:]
					}
				}
				if len(line) > 0 {
					result = append(result, line)
				}
			}
		}
		return result
	}

	// Print table
	topBorder := "┌" + strings.Repeat("─", maxNameLen+2) + "┬" + strings.Repeat("─", maxCmdLen+2) + "┐"
	headerSep := "├" + strings.Repeat("─", maxNameLen+2) + "┼" + strings.Repeat("─", maxCmdLen+2) + "┤"
	rowSep := "├" + strings.Repeat("─", maxNameLen+2) + "┼" + strings.Repeat("─", maxCmdLen+2) + "┤"
	bottomBorder := "└" + strings.Repeat("─", maxNameLen+2) + "┴" + strings.Repeat("─", maxCmdLen+2) + "┘"

	fmt.Println(topBorder)
	fmt.Printf("│ \033[1m%-*s\033[0m │ \033[1m%-*s\033[0m │\n", maxNameLen, "ALIAS", maxCmdLen, "COMMAND")
	fmt.Println(headerSep)

	for i, a := range aliases {
		wrappedLines := wrapText(a.cmd, maxCmdLen)
		for j, line := range wrappedLines {
			if j == 0 {
				// First line: show alias name
				fmt.Printf("│ \033[36m%-*s\033[0m │ %-*s │\n", maxNameLen, a.name, maxCmdLen, line)
			} else {
				// Continuation lines: empty alias column
				fmt.Printf("│ %-*s │ %-*s │\n", maxNameLen, "", maxCmdLen, line)
			}
		}
		// Row separator (except for last row)
		if i < len(aliases)-1 {
			fmt.Println(rowSep)
		}
	}
	fmt.Println(bottomBorder)
	return nil
}

func applyAliases(akaDir string) error {
	entries, err := os.ReadDir(akaDir)
	if err != nil {
		return err
	}
	fmt.Println("# Aliases generated by aka")
	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".alias") {
			aliasName := strings.TrimSuffix(entry.Name(), ".alias")
			filePath := filepath.Join(akaDir, entry.Name())
			content, err := os.ReadFile(filePath)
			if err != nil {
				return err
			}
			cmd := strings.TrimSpace(string(content))
			fmt.Printf("%s() {\n    %s\n}\n\n", aliasName, cmd)
		}
	}
	return nil
}
